{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Orali Money Documentation Orali Money for Android is a collaboration between GNU Taler and My Oral Village to create a mobile wallet that empowers people traditionally excluded from financial systems. Documentation Sections User Guide : For partners and end-users. Learn how to access, install, and use the application. Developer Guide : For contributors. Learn about the architecture, setup, and development process. Archive 2025 Demo (2025) fooBaz Contribution Statistics : Github Insights got borked when repo got corrupted AI Integration : Details use of AI by team fooBaz Initial Mockup : First mockup of OIM Wallet 2024 Google Summer of Code : GSOC '24 report by Amr Salah 2023 Google Summer of Code : GSOC '23 report by Iv\u00e1n \u00c1valos","title":"Home"},{"location":"#welcome-to-orali-money-documentation","text":"Orali Money for Android is a collaboration between GNU Taler and My Oral Village to create a mobile wallet that empowers people traditionally excluded from financial systems.","title":"Welcome to Orali Money Documentation"},{"location":"#documentation-sections","text":"User Guide : For partners and end-users. Learn how to access, install, and use the application. Developer Guide : For contributors. Learn about the architecture, setup, and development process.","title":"Documentation Sections"},{"location":"#archive","text":"","title":"Archive"},{"location":"#2025","text":"Demo (2025) fooBaz Contribution Statistics : Github Insights got borked when repo got corrupted AI Integration : Details use of AI by team fooBaz Initial Mockup : First mockup of OIM Wallet","title":"2025"},{"location":"#2024","text":"Google Summer of Code : GSOC '24 report by Amr Salah","title":"2024"},{"location":"#2023","text":"Google Summer of Code : GSOC '23 report by Iv\u00e1n \u00c1valos","title":"2023"},{"location":"developer-guide/","text":"Developer Guide Installation (For Developers) 1. Clone the Repository By HTTPS ##### HTTPS git clone https://github.com/csc301-2025-f/project-9-Orali-Project-for-Android.git cd project-9-Orali-Project-for-Android Note that you may need to authenticate with your GitHub credentials. By SSH ##### SSH git clone git@github.com:csc301-2025-f/project-9-Orali-Project-for-Android.git cd project-9-Orali-Project-for-Android 2. Build the Project Ensure the Java Development Kit 17 (JDK 17) is installed before running the Gradle commands below. Windows (Command Prompt and Powershell) ##### Windows (Command Prompt) gradlew.bat :wallet:build #### Windows (Powershell) .\\gradlew.bat :wallet:build Linux and Mac ##### Linux / Mac ./gradlew :wallet:build Tech Stack Languages - Kotlin (JVM 17) - Jetpack Compose (UI) - Kotlin Serialization Build & Tooling - Gradle - Android Gradle Plugin 8.9.2 - Protobuf (Lite runtime) - Git (commit-based nightly versioning) Android - minSdk 26 - targetSdk 35 - compileSdk 35 - ViewBinding + Compose - Product Flavors: fdroid , google , nightly - ABI Splits: armeabi-v7a , arm64-v8a , x86 , x86_64 Major Libraries - Compose BOM 2025.05.00 - Material3 - ConstraintLayout - Lifecycle ViewModel + LiveData - Navigation Component (Safe Args plugin) - DataStore + Protobuf - Coil (images) - ZXing (QR) - Markwon (Markdown rendering) - Ktor Client (Networking) - Qtart AAR (Crypto / Logic) - JNA - Apache Commons Text Testing - JUnit 4.13.2 - org.json Architecture Diagram High-level architecture of the Orali Money Android application. Architecture Overview The application follows a clean separation of concerns, organized into three main layers: Orchestration Layer : MainFragment : Acts as the central orchestrator, managing the overall state and transitions between different modes (Standard vs. OIM). OIM Context (UI Layer) : Operates exclusively in Landscape Orientation . Screens : OIMHomeScreen (entry), OIMChestScreen (main dashboard), OimSendApp (sending flow), and OIMReceiveScreen (receiving flow). Visual Components : StackedNotes handles the rendering of currency stacks. Users can interact with these stacks to view details via NotePreviewOverlay or expand them using NotesGalleryOverlay . History : TransactionHistoryView visualizes past transactions (e.g., the River View). Data & Logic Layer : MainViewModel : Serves as the bridge between the UI and the underlying data managers. Managers : PeerManager : Handles P2P communication (Push/Pull). BalanceManager : Manages the current wallet state and funds. TransactionManager : Handles transaction history and persistence. WithdrawManager : Manages withdrawal operations (specifically for Test KUDOS). This architecture ensures that UI components remain lightweight and focused on presentation, while business logic and data management are centralized in the ViewModel and Managers. Design Rationale Concurrency, Performance, and Real-World Devices OIM is designed for environments where devices are modest and resources are limited. The goal was to build something that behaves the same way on a modern phone and on older devices such as Tecno Spark 7 , Itel A56 , Tecno Pop series , Samsung J2 , Samsung A10 , and similar models that are still heavily used across West Africa. Many of these phones run with 1 GB or 2 GB of RAM, limited CPU power, and storage that becomes slow when the device fills up. These constraints shaped the entire architecture. Minimal Threading for Predictability The app uses a mostly single thread model, because the dataset is small and does not justify multiple threads. A simple architecture works better when the hardware is not powerful. It avoids complicated coordination between coroutines. Lifecycle events are easier to reason about. UI updates always occur in a predictable sequence. There is less chance of race conditions or partial updates. Debugging becomes straightforward because logic runs in a single flow. This approach reduces surprises and ensures that the interface feels stable even on phones that struggle under heavier workloads. How Older Phones Influence the Design In the communities where OIM will be used, users often rely on slow devices that are several years old. These devices typically have: limited RAM slower multi core processors weak GPU pipelines slow eMMC storage fragile thermal performance Running several asynchronous tasks at once can cause stutters or frame drops. Even lightweight background work can cause delays if the device is already under strain from Android services or Google Play components. Keeping OIM lightweight avoids these issues and keeps the experience smooth. Safe Use of Background Work Some operations still run off the main thread, such as small parsing tasks or loading local note images. However: these are short lived they never involve heavy computation they avoid adding pressure to the system This maintains consistent rendering and protects the user from slowdowns. Backend Limitations and On Device Processing The backend that powers OIM is managed by partner organizations and cannot be modified. The OIM team could not change any schema, add metadata, or restructure responses. This imposed several limitations. What Could Not Be Changed backend response format transaction structure available fields metadata support categorization additional endpoints Since the backend could not be touched, the app performs all computation for the river view on the device itself. What the Device Computes transaction grouping scaling layout logic metaphor mapping date and time translation amount based sizing The river view works fully offline using only the minimal transaction data provided. This allows total independence from backend capabilities while still maintaining visual richness. Why the App Does Not Use AI There were several reasons why AI was intentionally excluded, even though it could help with categorization and insights. No Backend Compute The backend environment does not have the CPU or GPU capacity to run even small AI models. There was no space to deploy transformers or even lightweight models. Running AI on the Device Is Not Practical Most users rely on low budget devices that cannot support quantized neural networks. Running inference on these devices would lead to: slow interfaces memory exhaustion thermal issues battery drain The risk outweighed the benefit. No AI Ready Data Because backend endpoints cannot be changed, the app receives no metadata about: transaction type category merchant labels description structure AI systems need structured data to generate meaningful insights. Without it, they would perform poorly. Stability Comes First The project prioritizes predictable behavior. Heavy AI computation contradicts that goal. Simplicity makes the application more reliable. Architecture and Code Structure The app uses an architecture that emphasizes clarity and maintainability. Separation of Responsibilities The MainViewModel manages state and data. Screens display the UI and contain no business logic. Composable components are reusable and lightweight. This creates a clean, understandable flow for future contributors. Reusable UI Components The app uses unified components across multiple screens. Examples include: stacked note renderer notes gallery overlay amount parser transaction mapping utilities Whenever assets or logic change, these updates propagate everywhere automatically. Resource Mapping All currency, note denominations, and transaction purposes map through a single place. This prevents errors and simplifies updates. Mock Database During development, the biggest structural limitation was the fact that the backend environment could not be consistently accessed, modified, or extended by the OIM engineering team. The partner organizations controlled the database schema, API endpoints, migration schedule, and infrastructure uptime. This created a situation where development needed to proceed at full speed without depending on backend availability. Because of this, OIM required a fully standalone, schema-accurate mock database that could act as a drop-in replacement for the real database during development. The motivation for this choice was much deeper than simply wanting \u201coffline testing\u201d. It emerged from a combination of practical, operational, and architectural needs. Ensuring Development Continuity The backend environment was frequently inaccessible due to: limited uptime during certain hours shared testing environments with other partner teams network instability when working from field locations maintenance windows and database resets outside our control Without a local mock database, UI development would have stalled for days at a time. The mock DB ensured that: developers could continue working when the real backend was offline UI prototypes were testable even during infrastructure outages QA could reproduce cases without needing to simulate server resets regressions could be caught without relying on backend data This decision protected the development timeline and allowed continuous iteration. A Controlled and Repeatable Data Environment The mock database also provided a stable sandbox. The real backend could not guarantee: consistent test data stable transaction IDs reproducible states for payment flows fixed balances for predictable screenshots The mock DB made it possible to create: deterministic test scenarios predictable transaction histories consistent wallet states reliable edge-case reproduction (zero balance, large inflows, rapid sends, etc.) This was essential for building and debugging features like the river view, note stacking animations, and consolidated purpose selection. Compatibility With the Real Schema The mock database was engineered to mirror the real schema exactly , including: field names field types table structures indexing assumptions timestamps transaction direction conventions This ensured that once the backend became available: integration required almost no changes switching from mock \u2192 real DB was a one-line swap every piece of UI logic already matched the real data model no mass refactoring was necessary The mock DB therefore served as a long-term investment in stability, not just a temporary convenience. Enabling Visual Feature Development Without Backend Support Several features in OIM, such as: the river view scaling farms and lakes stacked note consolidation amount mapping into denominations date icon assignment all required derived or aggregated data that the backend did not provide. The mock DB allowed local generation of: synthetic transaction histories large sequences of inflows and outflows stress test cases unusual patterns (e.g., clustered sends, missing purposes, extreme amounts) Without this, it would have been impossible to test the visual design under realistic workloads. Protecting the Backend From Accidental Load During development, UI screens refresh state frequently, especially when testing animation loops or rapid interactions. Running these tests directly against the real backend could have: created unnecessary load polluted production-adjacent logs generated accidental transactions triggered rate-limit or throttle protections introduced audit noise for partner teams The mock DB acted as a safety barrier, absorbing all local experimentation and ensuring the backend remained stable and clean. Future Integration Safety Because the mock DB is structurally identical to the partner database, any future backend improvements or migrations will only require: updating a single mapping layer reusing all existing UI logic leaving the composables and ViewModel untouched This makes the architecture long-lived and maintainable. Automated Testing and Deployment This repository does not have automated testing. The Taler wallet depends on legacy code to run, and large scale unit testing was out of the scope of this project. Orali Money contains developer releases on this repository and will have official releases on the F-Droid store. Coding Guidelines We follow Kotlin style guidelines and Android Best Practices . In addition, we use ktlint . Documentation Deployment This documentation is built with MkDocs . Local Development To preview the documentation locally: Install MkDocs and Material theme: bash pip install mkdocs mkdocs-material Run the development server: bash mkdocs serve Open http://127.0.0.1:8000 in your browser. Deploying to GitHub Pages To deploy the documentation to GitHub Pages: Ensure you have permissions to push to the repository. Run the deployment command: bash mkdocs gh-deploy This will build the static site and push it to the gh-pages branch. Ensure GitHub Pages is configured to serve from this branch in the repository settings.","title":"Developer Guide"},{"location":"developer-guide/#developer-guide","text":"","title":"Developer Guide"},{"location":"developer-guide/#installation-for-developers","text":"","title":"Installation (For Developers)"},{"location":"developer-guide/#1-clone-the-repository","text":"By HTTPS ##### HTTPS git clone https://github.com/csc301-2025-f/project-9-Orali-Project-for-Android.git cd project-9-Orali-Project-for-Android Note that you may need to authenticate with your GitHub credentials. By SSH ##### SSH git clone git@github.com:csc301-2025-f/project-9-Orali-Project-for-Android.git cd project-9-Orali-Project-for-Android","title":"1. Clone the Repository"},{"location":"developer-guide/#2-build-the-project","text":"Ensure the Java Development Kit 17 (JDK 17) is installed before running the Gradle commands below. Windows (Command Prompt and Powershell) ##### Windows (Command Prompt) gradlew.bat :wallet:build #### Windows (Powershell) .\\gradlew.bat :wallet:build Linux and Mac ##### Linux / Mac ./gradlew :wallet:build","title":"2. Build the Project"},{"location":"developer-guide/#tech-stack","text":"Languages - Kotlin (JVM 17) - Jetpack Compose (UI) - Kotlin Serialization Build & Tooling - Gradle - Android Gradle Plugin 8.9.2 - Protobuf (Lite runtime) - Git (commit-based nightly versioning) Android - minSdk 26 - targetSdk 35 - compileSdk 35 - ViewBinding + Compose - Product Flavors: fdroid , google , nightly - ABI Splits: armeabi-v7a , arm64-v8a , x86 , x86_64 Major Libraries - Compose BOM 2025.05.00 - Material3 - ConstraintLayout - Lifecycle ViewModel + LiveData - Navigation Component (Safe Args plugin) - DataStore + Protobuf - Coil (images) - ZXing (QR) - Markwon (Markdown rendering) - Ktor Client (Networking) - Qtart AAR (Crypto / Logic) - JNA - Apache Commons Text Testing - JUnit 4.13.2 - org.json","title":"Tech Stack"},{"location":"developer-guide/#architecture-diagram","text":"High-level architecture of the Orali Money Android application. Architecture Overview The application follows a clean separation of concerns, organized into three main layers: Orchestration Layer : MainFragment : Acts as the central orchestrator, managing the overall state and transitions between different modes (Standard vs. OIM). OIM Context (UI Layer) : Operates exclusively in Landscape Orientation . Screens : OIMHomeScreen (entry), OIMChestScreen (main dashboard), OimSendApp (sending flow), and OIMReceiveScreen (receiving flow). Visual Components : StackedNotes handles the rendering of currency stacks. Users can interact with these stacks to view details via NotePreviewOverlay or expand them using NotesGalleryOverlay . History : TransactionHistoryView visualizes past transactions (e.g., the River View). Data & Logic Layer : MainViewModel : Serves as the bridge between the UI and the underlying data managers. Managers : PeerManager : Handles P2P communication (Push/Pull). BalanceManager : Manages the current wallet state and funds. TransactionManager : Handles transaction history and persistence. WithdrawManager : Manages withdrawal operations (specifically for Test KUDOS). This architecture ensures that UI components remain lightweight and focused on presentation, while business logic and data management are centralized in the ViewModel and Managers.","title":"Architecture Diagram"},{"location":"developer-guide/#design-rationale","text":"","title":"Design Rationale"},{"location":"developer-guide/#concurrency-performance-and-real-world-devices","text":"OIM is designed for environments where devices are modest and resources are limited. The goal was to build something that behaves the same way on a modern phone and on older devices such as Tecno Spark 7 , Itel A56 , Tecno Pop series , Samsung J2 , Samsung A10 , and similar models that are still heavily used across West Africa. Many of these phones run with 1 GB or 2 GB of RAM, limited CPU power, and storage that becomes slow when the device fills up. These constraints shaped the entire architecture.","title":"Concurrency, Performance, and Real-World Devices"},{"location":"developer-guide/#minimal-threading-for-predictability","text":"The app uses a mostly single thread model, because the dataset is small and does not justify multiple threads. A simple architecture works better when the hardware is not powerful. It avoids complicated coordination between coroutines. Lifecycle events are easier to reason about. UI updates always occur in a predictable sequence. There is less chance of race conditions or partial updates. Debugging becomes straightforward because logic runs in a single flow. This approach reduces surprises and ensures that the interface feels stable even on phones that struggle under heavier workloads.","title":"Minimal Threading for Predictability"},{"location":"developer-guide/#how-older-phones-influence-the-design","text":"In the communities where OIM will be used, users often rely on slow devices that are several years old. These devices typically have: limited RAM slower multi core processors weak GPU pipelines slow eMMC storage fragile thermal performance Running several asynchronous tasks at once can cause stutters or frame drops. Even lightweight background work can cause delays if the device is already under strain from Android services or Google Play components. Keeping OIM lightweight avoids these issues and keeps the experience smooth.","title":"How Older Phones Influence the Design"},{"location":"developer-guide/#safe-use-of-background-work","text":"Some operations still run off the main thread, such as small parsing tasks or loading local note images. However: these are short lived they never involve heavy computation they avoid adding pressure to the system This maintains consistent rendering and protects the user from slowdowns.","title":"Safe Use of Background Work"},{"location":"developer-guide/#backend-limitations-and-on-device-processing","text":"The backend that powers OIM is managed by partner organizations and cannot be modified. The OIM team could not change any schema, add metadata, or restructure responses. This imposed several limitations.","title":"Backend Limitations and On Device Processing"},{"location":"developer-guide/#what-could-not-be-changed","text":"backend response format transaction structure available fields metadata support categorization additional endpoints Since the backend could not be touched, the app performs all computation for the river view on the device itself.","title":"What Could Not Be Changed"},{"location":"developer-guide/#what-the-device-computes","text":"transaction grouping scaling layout logic metaphor mapping date and time translation amount based sizing The river view works fully offline using only the minimal transaction data provided. This allows total independence from backend capabilities while still maintaining visual richness.","title":"What the Device Computes"},{"location":"developer-guide/#why-the-app-does-not-use-ai","text":"There were several reasons why AI was intentionally excluded, even though it could help with categorization and insights.","title":"Why the App Does Not Use AI"},{"location":"developer-guide/#no-backend-compute","text":"The backend environment does not have the CPU or GPU capacity to run even small AI models. There was no space to deploy transformers or even lightweight models.","title":"No Backend Compute"},{"location":"developer-guide/#running-ai-on-the-device-is-not-practical","text":"Most users rely on low budget devices that cannot support quantized neural networks. Running inference on these devices would lead to: slow interfaces memory exhaustion thermal issues battery drain The risk outweighed the benefit.","title":"Running AI on the Device Is Not Practical"},{"location":"developer-guide/#no-ai-ready-data","text":"Because backend endpoints cannot be changed, the app receives no metadata about: transaction type category merchant labels description structure AI systems need structured data to generate meaningful insights. Without it, they would perform poorly.","title":"No AI Ready Data"},{"location":"developer-guide/#stability-comes-first","text":"The project prioritizes predictable behavior. Heavy AI computation contradicts that goal. Simplicity makes the application more reliable.","title":"Stability Comes First"},{"location":"developer-guide/#architecture-and-code-structure","text":"The app uses an architecture that emphasizes clarity and maintainability.","title":"Architecture and Code Structure"},{"location":"developer-guide/#separation-of-responsibilities","text":"The MainViewModel manages state and data. Screens display the UI and contain no business logic. Composable components are reusable and lightweight. This creates a clean, understandable flow for future contributors.","title":"Separation of Responsibilities"},{"location":"developer-guide/#reusable-ui-components","text":"The app uses unified components across multiple screens. Examples include: stacked note renderer notes gallery overlay amount parser transaction mapping utilities Whenever assets or logic change, these updates propagate everywhere automatically.","title":"Reusable UI Components"},{"location":"developer-guide/#resource-mapping","text":"All currency, note denominations, and transaction purposes map through a single place. This prevents errors and simplifies updates.","title":"Resource Mapping"},{"location":"developer-guide/#mock-database","text":"During development, the biggest structural limitation was the fact that the backend environment could not be consistently accessed, modified, or extended by the OIM engineering team. The partner organizations controlled the database schema, API endpoints, migration schedule, and infrastructure uptime. This created a situation where development needed to proceed at full speed without depending on backend availability. Because of this, OIM required a fully standalone, schema-accurate mock database that could act as a drop-in replacement for the real database during development. The motivation for this choice was much deeper than simply wanting \u201coffline testing\u201d. It emerged from a combination of practical, operational, and architectural needs.","title":"Mock Database"},{"location":"developer-guide/#ensuring-development-continuity","text":"The backend environment was frequently inaccessible due to: limited uptime during certain hours shared testing environments with other partner teams network instability when working from field locations maintenance windows and database resets outside our control Without a local mock database, UI development would have stalled for days at a time. The mock DB ensured that: developers could continue working when the real backend was offline UI prototypes were testable even during infrastructure outages QA could reproduce cases without needing to simulate server resets regressions could be caught without relying on backend data This decision protected the development timeline and allowed continuous iteration.","title":"Ensuring Development Continuity"},{"location":"developer-guide/#a-controlled-and-repeatable-data-environment","text":"The mock database also provided a stable sandbox. The real backend could not guarantee: consistent test data stable transaction IDs reproducible states for payment flows fixed balances for predictable screenshots The mock DB made it possible to create: deterministic test scenarios predictable transaction histories consistent wallet states reliable edge-case reproduction (zero balance, large inflows, rapid sends, etc.) This was essential for building and debugging features like the river view, note stacking animations, and consolidated purpose selection.","title":"A Controlled and Repeatable Data Environment"},{"location":"developer-guide/#compatibility-with-the-real-schema","text":"The mock database was engineered to mirror the real schema exactly , including: field names field types table structures indexing assumptions timestamps transaction direction conventions This ensured that once the backend became available: integration required almost no changes switching from mock \u2192 real DB was a one-line swap every piece of UI logic already matched the real data model no mass refactoring was necessary The mock DB therefore served as a long-term investment in stability, not just a temporary convenience.","title":"Compatibility With the Real Schema"},{"location":"developer-guide/#enabling-visual-feature-development-without-backend-support","text":"Several features in OIM, such as: the river view scaling farms and lakes stacked note consolidation amount mapping into denominations date icon assignment all required derived or aggregated data that the backend did not provide. The mock DB allowed local generation of: synthetic transaction histories large sequences of inflows and outflows stress test cases unusual patterns (e.g., clustered sends, missing purposes, extreme amounts) Without this, it would have been impossible to test the visual design under realistic workloads.","title":"Enabling Visual Feature Development Without Backend Support"},{"location":"developer-guide/#protecting-the-backend-from-accidental-load","text":"During development, UI screens refresh state frequently, especially when testing animation loops or rapid interactions. Running these tests directly against the real backend could have: created unnecessary load polluted production-adjacent logs generated accidental transactions triggered rate-limit or throttle protections introduced audit noise for partner teams The mock DB acted as a safety barrier, absorbing all local experimentation and ensuring the backend remained stable and clean.","title":"Protecting the Backend From Accidental Load"},{"location":"developer-guide/#future-integration-safety","text":"Because the mock DB is structurally identical to the partner database, any future backend improvements or migrations will only require: updating a single mapping layer reusing all existing UI logic leaving the composables and ViewModel untouched This makes the architecture long-lived and maintainable.","title":"Future Integration Safety"},{"location":"developer-guide/#automated-testing-and-deployment","text":"This repository does not have automated testing. The Taler wallet depends on legacy code to run, and large scale unit testing was out of the scope of this project. Orali Money contains developer releases on this repository and will have official releases on the F-Droid store.","title":"Automated Testing and Deployment"},{"location":"developer-guide/#coding-guidelines","text":"We follow Kotlin style guidelines and Android Best Practices . In addition, we use ktlint .","title":"Coding Guidelines"},{"location":"developer-guide/#documentation-deployment","text":"This documentation is built with MkDocs .","title":"Documentation Deployment"},{"location":"developer-guide/#local-development","text":"To preview the documentation locally: Install MkDocs and Material theme: bash pip install mkdocs mkdocs-material Run the development server: bash mkdocs serve Open http://127.0.0.1:8000 in your browser.","title":"Local Development"},{"location":"developer-guide/#deploying-to-github-pages","text":"To deploy the documentation to GitHub Pages: Ensure you have permissions to push to the repository. Run the deployment command: bash mkdocs gh-deploy This will build the static site and push it to the gh-pages branch. Ensure GitHub Pages is configured to serve from this branch in the repository settings.","title":"Deploying to GitHub Pages"},{"location":"foobaz-contrib/","text":"","title":"fooBaz Contrib"},{"location":"gsoc-23-ivan-avalos-report/","text":"Link to the Android source code Goals of the project Anastasis is a key recovery system that allows users to create encrypted backups of their keys or secrets, split across multiple service providers, that can be recovered without needing a password. The keys are protected using a key derived from the identity attributes of the user, and can only be recovered by answering a series of verification steps defined by the user. The main goal of this Google Summer of Code project was to integrate Anastasis into the Taler Android wallet, in order to allow users to create encrypted and distributed backups of their wallet keys. This could only be achieved by either implementing Anastasis functionality within the wallet app, or creating a separate Anastasis app and enabling integration between the two apps. What I did I went for the second option and created a separate Anastasis app, which has the advantage of allowing Anastasis to be easily used for other use cases that don't involve the wallet. Besides, it gave me the freedom to build the app with a more suitable architecture. The core functionality for both the wallet and the Anastasis client is built into the same component: \u201cwallet-core\u201d, written in TypeScript. The Taler mobile apps and the web extension communicate with wallet-core using a consistent and well-documented JSON API. wallet-core.git wallet-core API docs In order to run wallet-core in the mobile apps, a TypeScript runtime needs to be embedded. There are many embedable runtimes, but some of them are too big, and not all of them are optimal for the purposes of Taler. QuickJS was chosen because of its small size and footprint, while having good standards compatibility (ES2020). QuickJS The Taler developers then created a cross-platform library built on top of QuickJS, tailor-made for running wallet-core in mobile, called \u201cquickjs-tart\u201d (nicknamed \u201cqtart,\u201d which stands for \u201c Q uickJS TA ler R un T ime\u201d). This library implements native QuickJS modules for cryptographic functions used by wallet-core, pre-compiles wallet-core to C, and provides a simple callback-based API that can be easily used from the mobile apps using native bridges (e.g. JNI). quickjs-tart.git The repository also includes qtart bindings for Android and iOS, which handle the bridging so that the apps don't have to. The Android bindings are available as a Maven library in Maven Central. The main challenge for the Anastasis app was that Anastasis uses a different API within wallet-core, that was originally not exposed to qtart. This API is designed as a stateless reducer, that takes a state and a transition and returns another state. Reducer API docs This is where things start to get interesting. In order to add Anastasis support to qtart, I had to expose the Anastasis API in wallet-core, implement a native QuickJS module for the Argon2 hash function required by Anastasis, and ensure that the \u201canastasis-core\u201d subpackage compiles for QuickJS. Once I had initial Anastasis support in qtart, the next step was to add support for the API in the new Android app. I reused from the wallet the code that manages the runtime and abstracts the API operations as requests, but modified it to work with the stateless model of the reducer. I also wrote Kotlin data structures and serialization logic for all the JSON objects in the API. At this point, I already had the starting point for the rest of the app. I wrote the app using Jetpack Compose, a technology that I wasn't very familiar with, so I had to learn it on the go, using the code of other free-software apps I've used before as examples. After some time, I managed to successfully create an abstraction for the reducer on top of Compose, using a global view model injected to the composables with Hilt. This view model contains the reducer state as a StateFlow, and a ReducerManager object that allows the views to safely interact with the API and update the state accordingly. The routing part was easy, as the reducer state contains a property that indicates the current step in the backup/recovery flow. The root composable listens to this property and shows the screen that corresponds to the backup/recovery step. At some point when implementing the backup flow, I realized that I had to use another (undocumented) API, separate to the reducer API, to contact the backup providers and fetch the list of supported verification methods. Again, I had to expose this API from wallet-core, build quickjs-tart with this modification, and implement this API on the app. And, at some point when implementing the recovery flow, I learned about YET another undocumented API, also separate to the reducer API, that was needed to contact the backup providers and fetch the list of secrets and recovery policies that match the identity attributes of the user. This resulted in another adventure, as this time, there was an issue with data encoding and decoding in qtart related to some cryptographic function that resulted in this API returning garbage. Florian helped me fix this issue, and soon afterwards, the API was working just fine! After some more work, I managed to have fully working backup and recovery, with many missing features, of course, but with the basics working just fine. The deadline was two days away, and I still had to implement the Taler integration! Oh, no! Well, unfortunately I couldn't get Taler integration working before the deadline, but at least I got the backup fees showing in the UI, and also added support for adding and removing backup providers, so that users can choose where to backup their keys and learn about the fees each provider demands beforehand. Isn't it cool? The current state The Anastasis app, as it stands now, provides basic support for backup and recovery of plain text keys (no files!). It allows users to manage the backup providers and learn about the fees they demand, as well as the fees per verification challenge (e.g. e-mail, SMS, question). What's left to do There are many missing features: Some challenge types are not yet supported, such as IBAN, physical mail, and TOTP. It is only possible to backup plain-text secrets, as there's no functionality in the app to upload and download files. There's no support for paying backup providers with Taler. There's no mechanism to trigger a key backup from the wallet. The reducer state can't be saved or restored from a JSON file, nor is it stored in shared preferences. I already have a working Anastasis instance that requires payments with Taler, which I've been using to test Taler integration and implement it in the app. This shouldn't take too long to fully implement, but afterwards, better integration with the wallet would still be needed to make the UX simpler. Of course, a mechanism to trigger a backup or recovery from the wallet is also missing. This will be implemented with an intent to the Anastasis app with the data to backup or recover, and another intent to the wallet app to hand-in the recovered data. Not too difficult! Merged code All the required code in wallet-core and qtart has already been merged. However, the latest wallet-core release (v0.9.3-dev.19, as of now) still doesn't include them. The code for the Anastasis app, present in the branch dev/ivan-avalos/anastasis of the taler-android mono-repo, hasn't been merged yet, and it's still pending review from the Taler developers. taler-android.git What I learned / challenges One of the hardest parts, and the one that took me the longest, was getting familiar with Jetpack Compose, especially creating an entire app using only Compose. How would the architecture look like? How was I supposed to translate the reducer model, not only to a screen, but to an entire app? I had to look in a lot of places for inspiration, as I wanted something clean, easy to work with, and above all, something that actually made sense. I ended up modelling the app after the architecture of the existing Anastasis web UI, written in React. As it turned out, Compose is not too different from React! Once I solved the initial challenges, I had a burst of creativity, which helped me work fast on implementing most of the functionality of the app. I refactored the app multiple times, and it always resulted in a cleaner codebase and a better architecture. I did my best to have a solid and sleek initial version, and so far it has paid off: less headaches when working with my own code, and a modern and good-looking app that I hope that will be a pleasure to use in the future. During this Google Summer of Code, I learned to not be afraid of new things, as in the end, there's always a way to figure them out. With enough help from other people, and enough exploration, it's possible for this process to be much shorter.","title":"GSOC 2023"},{"location":"gsoc-23-ivan-avalos-report/#goals-of-the-project","text":"Anastasis is a key recovery system that allows users to create encrypted backups of their keys or secrets, split across multiple service providers, that can be recovered without needing a password. The keys are protected using a key derived from the identity attributes of the user, and can only be recovered by answering a series of verification steps defined by the user. The main goal of this Google Summer of Code project was to integrate Anastasis into the Taler Android wallet, in order to allow users to create encrypted and distributed backups of their wallet keys. This could only be achieved by either implementing Anastasis functionality within the wallet app, or creating a separate Anastasis app and enabling integration between the two apps.","title":"Goals of the project"},{"location":"gsoc-23-ivan-avalos-report/#what-i-did","text":"I went for the second option and created a separate Anastasis app, which has the advantage of allowing Anastasis to be easily used for other use cases that don't involve the wallet. Besides, it gave me the freedom to build the app with a more suitable architecture. The core functionality for both the wallet and the Anastasis client is built into the same component: \u201cwallet-core\u201d, written in TypeScript. The Taler mobile apps and the web extension communicate with wallet-core using a consistent and well-documented JSON API. wallet-core.git wallet-core API docs In order to run wallet-core in the mobile apps, a TypeScript runtime needs to be embedded. There are many embedable runtimes, but some of them are too big, and not all of them are optimal for the purposes of Taler. QuickJS was chosen because of its small size and footprint, while having good standards compatibility (ES2020). QuickJS The Taler developers then created a cross-platform library built on top of QuickJS, tailor-made for running wallet-core in mobile, called \u201cquickjs-tart\u201d (nicknamed \u201cqtart,\u201d which stands for \u201c Q uickJS TA ler R un T ime\u201d). This library implements native QuickJS modules for cryptographic functions used by wallet-core, pre-compiles wallet-core to C, and provides a simple callback-based API that can be easily used from the mobile apps using native bridges (e.g. JNI). quickjs-tart.git The repository also includes qtart bindings for Android and iOS, which handle the bridging so that the apps don't have to. The Android bindings are available as a Maven library in Maven Central. The main challenge for the Anastasis app was that Anastasis uses a different API within wallet-core, that was originally not exposed to qtart. This API is designed as a stateless reducer, that takes a state and a transition and returns another state. Reducer API docs This is where things start to get interesting. In order to add Anastasis support to qtart, I had to expose the Anastasis API in wallet-core, implement a native QuickJS module for the Argon2 hash function required by Anastasis, and ensure that the \u201canastasis-core\u201d subpackage compiles for QuickJS. Once I had initial Anastasis support in qtart, the next step was to add support for the API in the new Android app. I reused from the wallet the code that manages the runtime and abstracts the API operations as requests, but modified it to work with the stateless model of the reducer. I also wrote Kotlin data structures and serialization logic for all the JSON objects in the API. At this point, I already had the starting point for the rest of the app. I wrote the app using Jetpack Compose, a technology that I wasn't very familiar with, so I had to learn it on the go, using the code of other free-software apps I've used before as examples. After some time, I managed to successfully create an abstraction for the reducer on top of Compose, using a global view model injected to the composables with Hilt. This view model contains the reducer state as a StateFlow, and a ReducerManager object that allows the views to safely interact with the API and update the state accordingly. The routing part was easy, as the reducer state contains a property that indicates the current step in the backup/recovery flow. The root composable listens to this property and shows the screen that corresponds to the backup/recovery step. At some point when implementing the backup flow, I realized that I had to use another (undocumented) API, separate to the reducer API, to contact the backup providers and fetch the list of supported verification methods. Again, I had to expose this API from wallet-core, build quickjs-tart with this modification, and implement this API on the app. And, at some point when implementing the recovery flow, I learned about YET another undocumented API, also separate to the reducer API, that was needed to contact the backup providers and fetch the list of secrets and recovery policies that match the identity attributes of the user. This resulted in another adventure, as this time, there was an issue with data encoding and decoding in qtart related to some cryptographic function that resulted in this API returning garbage. Florian helped me fix this issue, and soon afterwards, the API was working just fine! After some more work, I managed to have fully working backup and recovery, with many missing features, of course, but with the basics working just fine. The deadline was two days away, and I still had to implement the Taler integration! Oh, no! Well, unfortunately I couldn't get Taler integration working before the deadline, but at least I got the backup fees showing in the UI, and also added support for adding and removing backup providers, so that users can choose where to backup their keys and learn about the fees each provider demands beforehand. Isn't it cool?","title":"What I did"},{"location":"gsoc-23-ivan-avalos-report/#the-current-state","text":"The Anastasis app, as it stands now, provides basic support for backup and recovery of plain text keys (no files!). It allows users to manage the backup providers and learn about the fees they demand, as well as the fees per verification challenge (e.g. e-mail, SMS, question).","title":"The current state"},{"location":"gsoc-23-ivan-avalos-report/#whats-left-to-do","text":"There are many missing features: Some challenge types are not yet supported, such as IBAN, physical mail, and TOTP. It is only possible to backup plain-text secrets, as there's no functionality in the app to upload and download files. There's no support for paying backup providers with Taler. There's no mechanism to trigger a key backup from the wallet. The reducer state can't be saved or restored from a JSON file, nor is it stored in shared preferences. I already have a working Anastasis instance that requires payments with Taler, which I've been using to test Taler integration and implement it in the app. This shouldn't take too long to fully implement, but afterwards, better integration with the wallet would still be needed to make the UX simpler. Of course, a mechanism to trigger a backup or recovery from the wallet is also missing. This will be implemented with an intent to the Anastasis app with the data to backup or recover, and another intent to the wallet app to hand-in the recovered data. Not too difficult!","title":"What's left to do"},{"location":"gsoc-23-ivan-avalos-report/#merged-code","text":"All the required code in wallet-core and qtart has already been merged. However, the latest wallet-core release (v0.9.3-dev.19, as of now) still doesn't include them. The code for the Anastasis app, present in the branch dev/ivan-avalos/anastasis of the taler-android mono-repo, hasn't been merged yet, and it's still pending review from the Taler developers. taler-android.git","title":"Merged code"},{"location":"gsoc-23-ivan-avalos-report/#what-i-learned-challenges","text":"One of the hardest parts, and the one that took me the longest, was getting familiar with Jetpack Compose, especially creating an entire app using only Compose. How would the architecture look like? How was I supposed to translate the reducer model, not only to a screen, but to an entire app? I had to look in a lot of places for inspiration, as I wanted something clean, easy to work with, and above all, something that actually made sense. I ended up modelling the app after the architecture of the existing Anastasis web UI, written in React. As it turned out, Compose is not too different from React! Once I solved the initial challenges, I had a burst of creativity, which helped me work fast on implementing most of the functionality of the app. I refactored the app multiple times, and it always resulted in a cleaner codebase and a better architecture. I did my best to have a solid and sleek initial version, and so far it has paid off: less headaches when working with my own code, and a modern and good-looking app that I hope that will be a pleasure to use in the future. During this Google Summer of Code, I learned to not be afraid of new things, as in the end, there's always a way to figure them out. With enough help from other people, and enough exploration, it's possible for this process to be much shorter.","title":"What I learned / challenges"},{"location":"gsoc-24-amr-salah-report/","text":"GSoC 2024 - Integration of GNU Anastasis With GNU Taler Wallet This repository contains the final report and work done regarding Google Summer of Code, 2024 @ GNU . Project Title: Integration of GNU Anastasis With GNU Taler Wallet Contributor: Amr Salaheddin Abdelhady Email: amrhady3@gmail.com Project Link: GNU Taler Git Repository - GSoC Website Overview The GNU Taler Anastasis is a key backup/recovery system that allows the user to securely deposit shares of a core secret with an open set of escrow providers, to recover it if the secret is lost. The core secret itself is protected from the escrow providers by giving each provider only part of the information, and additionally by encrypting it with an identity-based key unknown to the providers. It prioritizes user privacy by implementing strong cryptographic protocols and privacy-enhancing features. Anastasis comes also with an Android app. The GNU Taler Wallet is another software developed within the GNU Taler project. It serves as a user interface for managing digital payments and transactions securely. The app enables users to store digital currency, make payments, and monitor transaction history. The Taler Wallet also comes with an Android app. The main objective of the project is to provide a mechanism for any Android app to use the Anastasis app to allow the user back up/recover his secrets, or to use the Wallet app to allow the user to make some payments for the caller app. Eventually, let the Anastasis app use the Wallet app to make the user pay for the backup providers. Objectives Design and implement a mechanism to allow any app to save and restore its secret keys via the Taler Anastasis app. [Completed] Design and implement a mechanism to allow any app to make its users pay for its services via the Taler Wallet app. [Completed] Integrate the Anastasis app with the Wallet app to allow the users to pay the Anastasis backup providers for their service via the Wallet app. [Completed] Work Done In this section, I will briefly about my journey throughout the project for people who are interested in getting some background about the current state of the Taler Wallet and the Taler Anastasis projects. The first part of the project: (Anastasis integration with other apps) The first objective in GSoC 2024 project is to make a communication mechanism for any app to navigate its users to the Anastasis app to back up his secret data of the caller app or recover his secret data. What I did here is that I fetched the abandoned Anastasis app project and spent some time trying to rebase it and make it up-to-date with the master to be ready to implement the new features. Then, I implemented the mechanism and made a document describing the Android Intent specification that must be matched and the different results that could be returned to the caller app. In addition, I created an example test app that uses the mechanism. Finally, I created a library to abstract all the mechanism functionalities. The second part of the project: (Wallet integration with other apps) The Wallet app has been allowing communication with it by the URIs. For example, a user can pay an online merchant by clicking on a taler URI (provided by the merchant) that opens the Wallet app to proceed with the payment. What I did here is that I extended this functionality by allowing any merchant app to use Android Intents to send the user to the Wallet app and also return to the merchant (caller) app with a payment result status. Furthermore, I implemented the multi-payment feature which allows the merchant to send multiple \"taler pay\" URIs in the Intent and these multiple payments will be displayed in the Wallet app for the user and he can pay all of them in one click! In addition, I created an example test app that uses the mechanism. Finally, I created the communication specification data for the Wallet app but this time I extended the RFC document that already has much information about the interaction with the GNU Taler Wallet. The third part of the project: (Anastasis integration with the Wallet) In the previous state of the Anastasis Android app, it was integrating the main functionalities of the anastasis core. However, backup and recovery via anastasis require that the user pay the backup providers for their service but there was no method provided in the app to do so. What I did is that I implemented the paying functionality by linking the Anastasis app to the Wallet app via the mechanism that I created previously. Now, the user can pay the Anastasis providers during the backup (Truths paying & Policies paying). The only thing that's left to do is to implement the paying during recovery (Challenge paying) which I haven't done because the anastasis-core (written in TypeScript) was not already implementing the \"ChallengePaying\" state, so we can't use this functionality in the Android app yet. Final Work Product Anastasis Integration With the Other Apps - Git Branch Anastasis Integration Specification - Document Wallet Integration With the Other Apps - Git Branch Wallet Integration Specification - RFC Document Git Branch Anastasis Integration With the Wallet - Git Branch Integration demo apps - Git Branch Thoughts on GSoC Lastly, I would like to thank my mentors, Christian Grothoff and Ivan Avalos for their continuous support and help during the project. It was exciting to be working on this interesting project!","title":"GSOC 2024"},{"location":"gsoc-24-amr-salah-report/#gsoc-2024-integration-of-gnu-anastasis-with-gnu-taler-wallet","text":"This repository contains the final report and work done regarding Google Summer of Code, 2024 @ GNU . Project Title: Integration of GNU Anastasis With GNU Taler Wallet Contributor: Amr Salaheddin Abdelhady Email: amrhady3@gmail.com Project Link: GNU Taler Git Repository - GSoC Website","title":"GSoC 2024 - Integration of GNU Anastasis With GNU Taler Wallet"},{"location":"gsoc-24-amr-salah-report/#overview","text":"The GNU Taler Anastasis is a key backup/recovery system that allows the user to securely deposit shares of a core secret with an open set of escrow providers, to recover it if the secret is lost. The core secret itself is protected from the escrow providers by giving each provider only part of the information, and additionally by encrypting it with an identity-based key unknown to the providers. It prioritizes user privacy by implementing strong cryptographic protocols and privacy-enhancing features. Anastasis comes also with an Android app. The GNU Taler Wallet is another software developed within the GNU Taler project. It serves as a user interface for managing digital payments and transactions securely. The app enables users to store digital currency, make payments, and monitor transaction history. The Taler Wallet also comes with an Android app. The main objective of the project is to provide a mechanism for any Android app to use the Anastasis app to allow the user back up/recover his secrets, or to use the Wallet app to allow the user to make some payments for the caller app. Eventually, let the Anastasis app use the Wallet app to make the user pay for the backup providers.","title":"Overview"},{"location":"gsoc-24-amr-salah-report/#objectives","text":"Design and implement a mechanism to allow any app to save and restore its secret keys via the Taler Anastasis app. [Completed] Design and implement a mechanism to allow any app to make its users pay for its services via the Taler Wallet app. [Completed] Integrate the Anastasis app with the Wallet app to allow the users to pay the Anastasis backup providers for their service via the Wallet app. [Completed]","title":"Objectives"},{"location":"gsoc-24-amr-salah-report/#work-done","text":"In this section, I will briefly about my journey throughout the project for people who are interested in getting some background about the current state of the Taler Wallet and the Taler Anastasis projects. The first part of the project: (Anastasis integration with other apps) The first objective in GSoC 2024 project is to make a communication mechanism for any app to navigate its users to the Anastasis app to back up his secret data of the caller app or recover his secret data. What I did here is that I fetched the abandoned Anastasis app project and spent some time trying to rebase it and make it up-to-date with the master to be ready to implement the new features. Then, I implemented the mechanism and made a document describing the Android Intent specification that must be matched and the different results that could be returned to the caller app. In addition, I created an example test app that uses the mechanism. Finally, I created a library to abstract all the mechanism functionalities. The second part of the project: (Wallet integration with other apps) The Wallet app has been allowing communication with it by the URIs. For example, a user can pay an online merchant by clicking on a taler URI (provided by the merchant) that opens the Wallet app to proceed with the payment. What I did here is that I extended this functionality by allowing any merchant app to use Android Intents to send the user to the Wallet app and also return to the merchant (caller) app with a payment result status. Furthermore, I implemented the multi-payment feature which allows the merchant to send multiple \"taler pay\" URIs in the Intent and these multiple payments will be displayed in the Wallet app for the user and he can pay all of them in one click! In addition, I created an example test app that uses the mechanism. Finally, I created the communication specification data for the Wallet app but this time I extended the RFC document that already has much information about the interaction with the GNU Taler Wallet. The third part of the project: (Anastasis integration with the Wallet) In the previous state of the Anastasis Android app, it was integrating the main functionalities of the anastasis core. However, backup and recovery via anastasis require that the user pay the backup providers for their service but there was no method provided in the app to do so. What I did is that I implemented the paying functionality by linking the Anastasis app to the Wallet app via the mechanism that I created previously. Now, the user can pay the Anastasis providers during the backup (Truths paying & Policies paying). The only thing that's left to do is to implement the paying during recovery (Challenge paying) which I haven't done because the anastasis-core (written in TypeScript) was not already implementing the \"ChallengePaying\" state, so we can't use this functionality in the Android app yet.","title":"Work Done"},{"location":"gsoc-24-amr-salah-report/#final-work-product","text":"Anastasis Integration With the Other Apps - Git Branch Anastasis Integration Specification - Document Wallet Integration With the Other Apps - Git Branch Wallet Integration Specification - RFC Document Git Branch Anastasis Integration With the Wallet - Git Branch Integration demo apps - Git Branch","title":"Final Work Product"},{"location":"gsoc-24-amr-salah-report/#thoughts-on-gsoc","text":"Lastly, I would like to thank my mentors, Christian Grothoff and Ivan Avalos for their continuous support and help during the project. It was exciting to be working on this interesting project!","title":"Thoughts on GSoC"},{"location":"initial-mockup/","text":"Orali Wallet for Android / fooBaz Product Details Q1: What is the product? There are approximately one billion people globally who are innumerate or illiterate, and they have historically been excluded from advancements in personal financial management. To bridge this gap, our partners have re-engineered the user interface and user experience of the existing Taler wallet. This decentralized and anonymous microtransaction wallet now uses pictographs and animations specifically designed to be accessible to people who are innumerate and illiterate. Our partners' current prototype is only available on iOS, but with the help of Taler's lead Android developer, we will be implementing the wallet for Android devices. Our partners are: My Oral Village Brett (Founder, Community Testing) David (Director of Partnerships) Taler Systems Marc (iOS developer; project lead) Iv\u00e1n (Android developer) Figma Mockup Demo: Interactive Figma Mockup Static Figma Mockup Q2: Who are your target users? Our primary users are illiterate and/or innumerate adults who lack formal schooling. The goal is to provide an easily and safely usable mobile wallet that makes sending money, validating transfers, and viewing transaction history intuitive and accessible. The wallet will aim to build their \"financial numeracy\", the ability to independently understand financial records in order to empower them with the ability to manage their money. Q3: Why would your users choose your product? What are they using today to solve their problem/need? For the world's one billion illiterate and innumerate adults, managing money has many challenges. They rely on informal methods like memorization, or trusting literate family members or agents, which exposes them to fraud, theft, and a lack of financial privacy and control. Existing mobile banking apps are not an option as they are text-based and require numerical literacy, effectively excluding this vast population. Orali Money addresses this gap by offering a visually intuitive and easily learnable mobile wallet designed specifically for those with little to no formal schooling. The reasons why people would want our product is firstly, It provides a form of intuitive financial independence. With an intuitive, graphic-based interface, users can send, receive, and verify money on their own, and keep it private as well, which many people would want to do. But they are unable to currently, due to their lack of understanding. Secondly, users can now understand their finances and track history reliably, which before, they would basically have to rely on memory, as they can't read or write. This project aligns with our partners core missions as well as My Oral Village is creating financial tools and projects that illiterate adults can use safely and independently. Taler focuses on building secure, private, and open-source payment systems. We are building a very similar app to one already made in iOS by Taler/MOV, so it aligns with our partner's mission very well. Q4: What are the user stories that make up the Minumum Viable Product (MVP)? User Stories Title Description Acceptance Criteria Sending Money I am a person who may be illiterate / innumerate and I need to send money to people who may have low literacy or be unfamiliar with technology. I need a user-friendly application that allows me to quickly and securely transfer funds. Upon opening the app, the user must press the centered treasure chest symbol to access their banking activities. After that, the user selects the \"giving hand\" symbol in the upper right-hand corner to start a transaction of giving money. At this stage, the user is presented with all denominations of local currency (currently only leones) where they can select them to increment the payment amount that they are sending. When they are done, they press the right hand in the upper right corner. This presents a screen of buttons denoting the destination of where their money will be sent (e.g. electricity). After pressing one of these buttons, a screen with a QR code is shown where this QR code is then scanned to have the money sent. Finally, the user is presented with a screen with arrows demonstrating the flow of money (from the money originally in their bank account) to the money after the transaction. Receiving Money As an adult user with low literacy and numeracy skills , I want clear and simple notifications when I receive money , so that I can immediately know and confirm the transaction without confusion . The user receives an in-app notification that they have received money (with an audio icon next to it, which can be pressed to hear the amount - being used primarily by those who are illiterate and/or innumerate). Afterward, they are then taken to a different page in the app which demonstrates the flow of money and how their bank balance has increased. Visual Transaction History As an adult user with limited literacy skills , I want to check past money transactions using visual representations , so that I can keep track of my financial activity without needing to read written records . - Transactions ordered chronologically and flow is easy to understand - Date of transaction is visually represented based on the current day (ie: if a transaction was done \"2 days ago\", visually represent it as \"2 days from today, user had X transaction\") - Can be easily explained by individuals who know the software and remembered by those with low literacy - Has \"advanced options\" for more detailed transactional records, but avoids it on the main UI/UX Onboarding/Demo Feature As a literate adult user who might not be extremely tech savvy, I would like there to be a demo transaction and walkthrough that familarizes me with the components of the app and how it should be used. I want this so I can easily show my illiterate / inumerate loved ones. Upon opening the app the first time, there should be a walkthrough that shows me how to interact with the basic features of the app. It should cover how to send/receive money and see transaction history, and use an OIM interface for the current demo mode in the Taller wallet. Partner Approval Q5: Have you decided on how you will build it? Share what you know now or tell us the options you are considering. We have decided to build Orali Money for Android using Kotlin with Jetpack Compose as our main UI toolkit. After considering alternatives (e.g., Scala, which was too enterprise-oriented with limited APIs), Kotlin with Compose provides the best support for modern Android development. Technology stack (current plan): - Frontend: Kotlin + Jetpack Compose (modern declarative UI framework for Android). - Backend: Out of scope for our team . Backend services and the payment engine are handled by Taler Systems . We will focus only on the UI and frontend logic:contentReference[oaicite:0]{index=0}. - Architecture: MVVM (Model\u2013View\u2013ViewModel) pattern for clean separation of concerns. - Build System: Gradle (Android Gradle Plugin) will manage project dependencies, build variants, and CI/CD integration. Gradle allows modular builds, dependency resolution, and seamless APK generation for different environments. - APIs / Integrations: - Device-native authentication (PIN, fingerprint, Face ID) rather than custom authentication:contentReference[oaicite:1]{index=1}. - Integration with GNU Taler ( taler.net ), a privacy-preserving payment system, for transaction processing and balance verification. - Graphics and icons from MyOralVillage\u2019s OIM project, adapted for Android. - Deployment: The app will be packaged as an APK and tested on both emulators and physical devices. Partner collaboration may also extend to publishing on the Google Play Store once features are production-ready. - Version Control / Collaboration: GitHub will serve as the central repository, shared with Ivan (partner Android developer) for asset and code synchronization:contentReference[oaicite:2]{index=2}. Intellectual Property Confidentiality Agreement Our code will be released on a FLOSS license We may upload our code to a public repository Our team will only reference the work we did in our resume, interviews, etc. Our partners communicated that our repository will be released under the GNU General Public License >= version 3. As such, we may freely run, share, distribute, and modify the software as we wish. Teamwork Details Q6: Have you met with your team? On our 2nd meeting together, we did some ice breakers and shared some fun facts about ourselves: The following meeting, we took some time to play a few discord games together: We have also been getting to know each other by chatting before meetings and on discord. Q7: What are the roles & responsibilities on the team? Amish Mamtani is the lead front end developer and product manager. He will be responsible for overall product management and front end development. Zaki Ali and Fares Alkorani will be working with Amish on product design and front end work, and will be working on testing as well. Anish Pai will focus on CI\\CD and testing and will support the front end team to ensure that their work is continuously scalable and passing our tests. Nathan Shea Ouedraogo served as the Project Lead and Project Manager. He will be maintaing the repository integrety and serve as the main point of contact between the partners and the team. He will also contribute to CI\\CD and front end development as needed. Q8: How will you work as a team? As a team, we have two 2-hour meetings per week, on Sundays and Thursdays, and one brief meeting on Wednesday. We meet on either Discord or Google Meets. For each meeting, we assign a scribe to take notes and a lead to run the meeting. We plan the agenda for the next meeting at the end of each one, ensuring every meeting has specific issues and tasks to address. These are all tracked in our meeting minutes. We also have a weekly 2-hour meeting with our partners every Tuesday. Since our team and our partners are spread across four time zones and three continents, we were only able to schedule one meeting before our first deliverable. Our initial meeting on September 23, 2025, covered introductions and an agreement on the project\u2019s Minimum Viable Product (MVP), which we defined through user stories. We also discussed our tech stack, how we will integrate with the existing project, and identified potential risks and mitigation strategies. Q9: How will you organize your team? Meeting schedule breakdown As outlined in the previous section, we will have 4 meetings per week, including one meeting with our partners. Below is a breakdown of the meetings: Wednesday Each team member gives small progress report / standup finalize what to present for TA and what proof we need finalize high level plan for next week's sprint Thursday Discuss meeting w/ TA Debrief last week's sprint / look for improvements and pain points Assign Issues and milestones on github Sunday each member gives a progress report / stand up identify pain points identify progress identify hurdles / roadblocks give proof / concrete examples of what we did consolidate progress reports into one high-level report for partner agree on high-level plan for next week's sprint agree on actionable items for sprint gather responsibles gather what we need from partners Tuesday meeting with partners present high level progress report / standup present idea for sprint for next week address partner concerns and integrate them into sprint Issues and Github Projects Our team will be using Github projects as the main team management platform. Each release / feature is organized into specific projects, and each project is composed of multiple concrete milestones. These milestones have issues assigned to them which we have agreed upon in our meeting, and dates which they are due by. Finally, we have meeting minutes to fall back on if we need to reference anything. If we have a major task, our project manager brings it up in the weekly sprint planning meeting (or a team member suggests it). We then discuss what sub tasks we need to delegate and which team members will be best suited for that role. We then assign issues and add it to the appropriate milestone. Issues are prioritized by issue dependency, and how critical an issue is to the overall project being implemented. Issues are organized in our Github project by either being in the \"TODO\" (not started/non-priority), \"WIP\" (work in progress; currently completing), \"review/testing\" (waiting approval or tests), or \"done\" (issue has been completed successfully). When all issues are in the \"done\" category, that means our feature has been thoroughly tested and released, and we are ready to move on to the next project. We have a workflow in github which automatically reminds assignees of open issues each day and when they are due. Another workflow sends biweekly reminders for milestones (which change to daily when the milestone is <= 2 days away or overdue). Communication We will be using Mumble and Discord for unofficial / casual conversations, email for official conversations, and BBB for video calls and presentations. Q10: What are the rules regarding how your team works? Our partners communicate mainly through outlook, and our project leader serves as the main point of contact. Our team is expected to communicate and read our internal discord at least once a day. We are held responsible through issue tracking, weekly standups, and progress reports with the TA. If a team member is not responsive, we will first try our best to get in contact with that team member. In the mean time, their work is delegated to other team members by the project manager. If they continue to be unresponsive and do not contribute, we will then escalate to the TA to take appropriate next steps. Organisation Details Q11. How does your team fit within the overall team organisation of the partner? We are a part of the android development team. We are rebuilding the existing iOS app into a native Android version that maintains the core interface while also integrating the Oral Information Management (OIM) interface. We\u2019ll be working closely with Iv\u00e1n \u00c1valos, the Android developer at Taler Systems who is also contributing to the Orali Money app. At the same time, we\u2019ll be reporting key milestones and design decisions to Brett Matthews (Founder, MyOralVillage), David Myhre (Director of Partnerships, MyOralVillage), and Marc Stibane (iOS Developer, Taler Systems). We believe this role is a strong fit for us because it is very front-end and user-experience focused, and our team has solid experience in both areas. For example, Amish worked on the Centre for Dreams app with UofT Blueprint, designing accessible user journeys for people with developmental disabilities. Fares brings front-end and UI/UX internship experience, along with industry knowledge of working with external stakeholders. Other team members also have internship and project experience in development and design, including areas such as backend and full stack development, giving us a strong and well-rounded foundation. Together, we are well-positioned to create solutions that prioritize accessibility, clarity, and usability for the app\u2019s target users. Q12. How does your project fit within the overall product from the partner? Our project fits into the partner\u2019s overall product as the Android version of the Orali Money app, designed to make money management accessible to users with different literacy and numeracy levels, including those who are illiterate or innumerate. While this is not the first prototype since an iOS version already exists, our work focuses on building an MVP for Android that expands the app\u2019s reach and makes it more accessible to its target users. The MVP will include core features such as sending money, making payments in stores, and maintaining a clear record of balances and past transactions. A major emphasis of our work is on the Oral Information Management (OIM) interface, which aims to improve usability and make the app intuitive for users who may struggle with traditional text or number-heavy interfaces. On the technical side, we will collaborate closely with Iv\u00e1n \u00c1valos (Android developer, Taler Systems) for guidance, while consulting Brett Matthews (Founder, MyOraliVillage), David Myhre (Director of Partnerships), and Marc Stibane (iOS Developer, Taler Systems) for key decisions and milestones. This ensures consistency across both iOS and Android development. For our partner, success means delivering a usable MVP on Android, with particular attention to the OIM component. This MVP will then be tested with the company and its target users, serving as the foundation for future iterations and improvements of the product. Potential Risks Q13: What are some potential risks to your project? Designing for low-literacy, low-numeracy users Creating an interface that is truly intuitive and understandable for illiterate/innumerate adults is a challenge. Even small design missteps (icons, flows, or colors) could confuse users. Scope creep and misaligned expectations Partners have flagged certain features as out-of-scope (e.g., onboarding, warnings, bank withdrawals). There is a risk of the team unintentionally expanding scope beyond what\u2019s feasible. Collaboration across iOS/Android teams Coordination with Ivan (Android dev) and Marc (iOS dev) may face challenges in asset/code sharing, version control, and ensuring design consistency. Limited experience with this unique user group Most of the team does not have direct experience designing for illiterate users, which may result in gaps between assumptions and actual user needs. Technical complexity of visual language Icons, animations, and graphic capacities (e.g., place value, tabular formats) are critical for OIM but may be difficult to implement smoothly on mobile devices. Q14: What are some potential mitigation strategies for the risks you identified? For user interface challenges: Prioritize user testing early with sample icons and flows. Focus on iterative design with feedback from partners in Sierra Leone who already work with target users. For scope creep: Clearly document and re-confirm with partners which features are in-scope vs. out-of-scope . Track any new feature ideas for later phases rather than committing immediately. For collaboration issues: Use a shared GitHub repo and maintain consistent documentation. Weekly sync meetings with Ivan and Marc will help align Android and iOS versions. For gaps in understanding user needs: Leverage partner expertise (Brett and David from MyOralVillage) to validate design assumptions. Conduct walkthroughs of the OIM demo to guide UI design. For technical complexity of graphics: Start with a simplified icon/animation set from the Salone OIM Library and gradually expand. Use Jetpack Compose\u2019s graphics/animation APIs, which are well-suited for custom UI elements.","title":"Initial Mockup"},{"location":"initial-mockup/#orali-wallet-for-android-foobaz","text":"","title":"Orali Wallet for Android / fooBaz"},{"location":"initial-mockup/#product-details","text":"","title":"Product Details"},{"location":"initial-mockup/#q1-what-is-the-product","text":"There are approximately one billion people globally who are innumerate or illiterate, and they have historically been excluded from advancements in personal financial management. To bridge this gap, our partners have re-engineered the user interface and user experience of the existing Taler wallet. This decentralized and anonymous microtransaction wallet now uses pictographs and animations specifically designed to be accessible to people who are innumerate and illiterate. Our partners' current prototype is only available on iOS, but with the help of Taler's lead Android developer, we will be implementing the wallet for Android devices. Our partners are: My Oral Village Brett (Founder, Community Testing) David (Director of Partnerships) Taler Systems Marc (iOS developer; project lead) Iv\u00e1n (Android developer) Figma Mockup Demo: Interactive Figma Mockup Static Figma Mockup","title":"Q1: What is the product?"},{"location":"initial-mockup/#q2-who-are-your-target-users","text":"Our primary users are illiterate and/or innumerate adults who lack formal schooling. The goal is to provide an easily and safely usable mobile wallet that makes sending money, validating transfers, and viewing transaction history intuitive and accessible. The wallet will aim to build their \"financial numeracy\", the ability to independently understand financial records in order to empower them with the ability to manage their money.","title":"Q2: Who are your target users?"},{"location":"initial-mockup/#q3-why-would-your-users-choose-your-product-what-are-they-using-today-to-solve-their-problemneed","text":"For the world's one billion illiterate and innumerate adults, managing money has many challenges. They rely on informal methods like memorization, or trusting literate family members or agents, which exposes them to fraud, theft, and a lack of financial privacy and control. Existing mobile banking apps are not an option as they are text-based and require numerical literacy, effectively excluding this vast population. Orali Money addresses this gap by offering a visually intuitive and easily learnable mobile wallet designed specifically for those with little to no formal schooling. The reasons why people would want our product is firstly, It provides a form of intuitive financial independence. With an intuitive, graphic-based interface, users can send, receive, and verify money on their own, and keep it private as well, which many people would want to do. But they are unable to currently, due to their lack of understanding. Secondly, users can now understand their finances and track history reliably, which before, they would basically have to rely on memory, as they can't read or write. This project aligns with our partners core missions as well as My Oral Village is creating financial tools and projects that illiterate adults can use safely and independently. Taler focuses on building secure, private, and open-source payment systems. We are building a very similar app to one already made in iOS by Taler/MOV, so it aligns with our partner's mission very well.","title":"Q3: Why would your users choose your product? What are they using today to solve their problem/need?"},{"location":"initial-mockup/#q4-what-are-the-user-stories-that-make-up-the-minumum-viable-product-mvp","text":"","title":"Q4: What are the user stories that make up the Minumum Viable Product (MVP)?"},{"location":"initial-mockup/#user-stories","text":"Title Description Acceptance Criteria Sending Money I am a person who may be illiterate / innumerate and I need to send money to people who may have low literacy or be unfamiliar with technology. I need a user-friendly application that allows me to quickly and securely transfer funds. Upon opening the app, the user must press the centered treasure chest symbol to access their banking activities. After that, the user selects the \"giving hand\" symbol in the upper right-hand corner to start a transaction of giving money. At this stage, the user is presented with all denominations of local currency (currently only leones) where they can select them to increment the payment amount that they are sending. When they are done, they press the right hand in the upper right corner. This presents a screen of buttons denoting the destination of where their money will be sent (e.g. electricity). After pressing one of these buttons, a screen with a QR code is shown where this QR code is then scanned to have the money sent. Finally, the user is presented with a screen with arrows demonstrating the flow of money (from the money originally in their bank account) to the money after the transaction. Receiving Money As an adult user with low literacy and numeracy skills , I want clear and simple notifications when I receive money , so that I can immediately know and confirm the transaction without confusion . The user receives an in-app notification that they have received money (with an audio icon next to it, which can be pressed to hear the amount - being used primarily by those who are illiterate and/or innumerate). Afterward, they are then taken to a different page in the app which demonstrates the flow of money and how their bank balance has increased. Visual Transaction History As an adult user with limited literacy skills , I want to check past money transactions using visual representations , so that I can keep track of my financial activity without needing to read written records . - Transactions ordered chronologically and flow is easy to understand - Date of transaction is visually represented based on the current day (ie: if a transaction was done \"2 days ago\", visually represent it as \"2 days from today, user had X transaction\") - Can be easily explained by individuals who know the software and remembered by those with low literacy - Has \"advanced options\" for more detailed transactional records, but avoids it on the main UI/UX Onboarding/Demo Feature As a literate adult user who might not be extremely tech savvy, I would like there to be a demo transaction and walkthrough that familarizes me with the components of the app and how it should be used. I want this so I can easily show my illiterate / inumerate loved ones. Upon opening the app the first time, there should be a walkthrough that shows me how to interact with the basic features of the app. It should cover how to send/receive money and see transaction history, and use an OIM interface for the current demo mode in the Taller wallet.","title":"User Stories"},{"location":"initial-mockup/#partner-approval","text":"","title":"Partner Approval"},{"location":"initial-mockup/#q5-have-you-decided-on-how-you-will-build-it-share-what-you-know-now-or-tell-us-the-options-you-are-considering","text":"We have decided to build Orali Money for Android using Kotlin with Jetpack Compose as our main UI toolkit. After considering alternatives (e.g., Scala, which was too enterprise-oriented with limited APIs), Kotlin with Compose provides the best support for modern Android development. Technology stack (current plan): - Frontend: Kotlin + Jetpack Compose (modern declarative UI framework for Android). - Backend: Out of scope for our team . Backend services and the payment engine are handled by Taler Systems . We will focus only on the UI and frontend logic:contentReference[oaicite:0]{index=0}. - Architecture: MVVM (Model\u2013View\u2013ViewModel) pattern for clean separation of concerns. - Build System: Gradle (Android Gradle Plugin) will manage project dependencies, build variants, and CI/CD integration. Gradle allows modular builds, dependency resolution, and seamless APK generation for different environments. - APIs / Integrations: - Device-native authentication (PIN, fingerprint, Face ID) rather than custom authentication:contentReference[oaicite:1]{index=1}. - Integration with GNU Taler ( taler.net ), a privacy-preserving payment system, for transaction processing and balance verification. - Graphics and icons from MyOralVillage\u2019s OIM project, adapted for Android. - Deployment: The app will be packaged as an APK and tested on both emulators and physical devices. Partner collaboration may also extend to publishing on the Google Play Store once features are production-ready. - Version Control / Collaboration: GitHub will serve as the central repository, shared with Ivan (partner Android developer) for asset and code synchronization:contentReference[oaicite:2]{index=2}.","title":"Q5: Have you decided on how you will build it? Share what you know now or tell us the options you are considering."},{"location":"initial-mockup/#intellectual-property-confidentiality-agreement","text":"Our code will be released on a FLOSS license We may upload our code to a public repository Our team will only reference the work we did in our resume, interviews, etc. Our partners communicated that our repository will be released under the GNU General Public License >= version 3. As such, we may freely run, share, distribute, and modify the software as we wish.","title":"Intellectual Property Confidentiality Agreement"},{"location":"initial-mockup/#teamwork-details","text":"","title":"Teamwork Details"},{"location":"initial-mockup/#q6-have-you-met-with-your-team","text":"On our 2nd meeting together, we did some ice breakers and shared some fun facts about ourselves: The following meeting, we took some time to play a few discord games together: We have also been getting to know each other by chatting before meetings and on discord.","title":"Q6: Have you met with your team?"},{"location":"initial-mockup/#q7-what-are-the-roles-responsibilities-on-the-team","text":"Amish Mamtani is the lead front end developer and product manager. He will be responsible for overall product management and front end development. Zaki Ali and Fares Alkorani will be working with Amish on product design and front end work, and will be working on testing as well. Anish Pai will focus on CI\\CD and testing and will support the front end team to ensure that their work is continuously scalable and passing our tests. Nathan Shea Ouedraogo served as the Project Lead and Project Manager. He will be maintaing the repository integrety and serve as the main point of contact between the partners and the team. He will also contribute to CI\\CD and front end development as needed.","title":"Q7: What are the roles &amp; responsibilities on the team?"},{"location":"initial-mockup/#q8-how-will-you-work-as-a-team","text":"As a team, we have two 2-hour meetings per week, on Sundays and Thursdays, and one brief meeting on Wednesday. We meet on either Discord or Google Meets. For each meeting, we assign a scribe to take notes and a lead to run the meeting. We plan the agenda for the next meeting at the end of each one, ensuring every meeting has specific issues and tasks to address. These are all tracked in our meeting minutes. We also have a weekly 2-hour meeting with our partners every Tuesday. Since our team and our partners are spread across four time zones and three continents, we were only able to schedule one meeting before our first deliverable. Our initial meeting on September 23, 2025, covered introductions and an agreement on the project\u2019s Minimum Viable Product (MVP), which we defined through user stories. We also discussed our tech stack, how we will integrate with the existing project, and identified potential risks and mitigation strategies.","title":"Q8: How will you work as a team?"},{"location":"initial-mockup/#q9-how-will-you-organize-your-team","text":"","title":"Q9: How will you organize your team?"},{"location":"initial-mockup/#meeting-schedule-breakdown","text":"As outlined in the previous section, we will have 4 meetings per week, including one meeting with our partners. Below is a breakdown of the meetings: Wednesday Each team member gives small progress report / standup finalize what to present for TA and what proof we need finalize high level plan for next week's sprint Thursday Discuss meeting w/ TA Debrief last week's sprint / look for improvements and pain points Assign Issues and milestones on github Sunday each member gives a progress report / stand up identify pain points identify progress identify hurdles / roadblocks give proof / concrete examples of what we did consolidate progress reports into one high-level report for partner agree on high-level plan for next week's sprint agree on actionable items for sprint gather responsibles gather what we need from partners Tuesday meeting with partners present high level progress report / standup present idea for sprint for next week address partner concerns and integrate them into sprint","title":"Meeting schedule breakdown"},{"location":"initial-mockup/#issues-and-github-projects","text":"Our team will be using Github projects as the main team management platform. Each release / feature is organized into specific projects, and each project is composed of multiple concrete milestones. These milestones have issues assigned to them which we have agreed upon in our meeting, and dates which they are due by. Finally, we have meeting minutes to fall back on if we need to reference anything. If we have a major task, our project manager brings it up in the weekly sprint planning meeting (or a team member suggests it). We then discuss what sub tasks we need to delegate and which team members will be best suited for that role. We then assign issues and add it to the appropriate milestone. Issues are prioritized by issue dependency, and how critical an issue is to the overall project being implemented. Issues are organized in our Github project by either being in the \"TODO\" (not started/non-priority), \"WIP\" (work in progress; currently completing), \"review/testing\" (waiting approval or tests), or \"done\" (issue has been completed successfully). When all issues are in the \"done\" category, that means our feature has been thoroughly tested and released, and we are ready to move on to the next project. We have a workflow in github which automatically reminds assignees of open issues each day and when they are due. Another workflow sends biweekly reminders for milestones (which change to daily when the milestone is <= 2 days away or overdue).","title":"Issues and Github Projects"},{"location":"initial-mockup/#communication","text":"We will be using Mumble and Discord for unofficial / casual conversations, email for official conversations, and BBB for video calls and presentations.","title":"Communication"},{"location":"initial-mockup/#q10-what-are-the-rules-regarding-how-your-team-works","text":"Our partners communicate mainly through outlook, and our project leader serves as the main point of contact. Our team is expected to communicate and read our internal discord at least once a day. We are held responsible through issue tracking, weekly standups, and progress reports with the TA. If a team member is not responsive, we will first try our best to get in contact with that team member. In the mean time, their work is delegated to other team members by the project manager. If they continue to be unresponsive and do not contribute, we will then escalate to the TA to take appropriate next steps.","title":"Q10: What are the rules regarding how your team works?"},{"location":"initial-mockup/#organisation-details","text":"","title":"Organisation Details"},{"location":"initial-mockup/#q11-how-does-your-team-fit-within-the-overall-team-organisation-of-the-partner","text":"We are a part of the android development team. We are rebuilding the existing iOS app into a native Android version that maintains the core interface while also integrating the Oral Information Management (OIM) interface. We\u2019ll be working closely with Iv\u00e1n \u00c1valos, the Android developer at Taler Systems who is also contributing to the Orali Money app. At the same time, we\u2019ll be reporting key milestones and design decisions to Brett Matthews (Founder, MyOralVillage), David Myhre (Director of Partnerships, MyOralVillage), and Marc Stibane (iOS Developer, Taler Systems). We believe this role is a strong fit for us because it is very front-end and user-experience focused, and our team has solid experience in both areas. For example, Amish worked on the Centre for Dreams app with UofT Blueprint, designing accessible user journeys for people with developmental disabilities. Fares brings front-end and UI/UX internship experience, along with industry knowledge of working with external stakeholders. Other team members also have internship and project experience in development and design, including areas such as backend and full stack development, giving us a strong and well-rounded foundation. Together, we are well-positioned to create solutions that prioritize accessibility, clarity, and usability for the app\u2019s target users.","title":"Q11. How does your team fit within the overall team organisation of the partner?"},{"location":"initial-mockup/#q12-how-does-your-project-fit-within-the-overall-product-from-the-partner","text":"Our project fits into the partner\u2019s overall product as the Android version of the Orali Money app, designed to make money management accessible to users with different literacy and numeracy levels, including those who are illiterate or innumerate. While this is not the first prototype since an iOS version already exists, our work focuses on building an MVP for Android that expands the app\u2019s reach and makes it more accessible to its target users. The MVP will include core features such as sending money, making payments in stores, and maintaining a clear record of balances and past transactions. A major emphasis of our work is on the Oral Information Management (OIM) interface, which aims to improve usability and make the app intuitive for users who may struggle with traditional text or number-heavy interfaces. On the technical side, we will collaborate closely with Iv\u00e1n \u00c1valos (Android developer, Taler Systems) for guidance, while consulting Brett Matthews (Founder, MyOraliVillage), David Myhre (Director of Partnerships), and Marc Stibane (iOS Developer, Taler Systems) for key decisions and milestones. This ensures consistency across both iOS and Android development. For our partner, success means delivering a usable MVP on Android, with particular attention to the OIM component. This MVP will then be tested with the company and its target users, serving as the foundation for future iterations and improvements of the product.","title":"Q12. How does your project fit within the overall product from the partner?"},{"location":"initial-mockup/#potential-risks","text":"","title":"Potential Risks"},{"location":"initial-mockup/#q13-what-are-some-potential-risks-to-your-project","text":"Designing for low-literacy, low-numeracy users Creating an interface that is truly intuitive and understandable for illiterate/innumerate adults is a challenge. Even small design missteps (icons, flows, or colors) could confuse users. Scope creep and misaligned expectations Partners have flagged certain features as out-of-scope (e.g., onboarding, warnings, bank withdrawals). There is a risk of the team unintentionally expanding scope beyond what\u2019s feasible. Collaboration across iOS/Android teams Coordination with Ivan (Android dev) and Marc (iOS dev) may face challenges in asset/code sharing, version control, and ensuring design consistency. Limited experience with this unique user group Most of the team does not have direct experience designing for illiterate users, which may result in gaps between assumptions and actual user needs. Technical complexity of visual language Icons, animations, and graphic capacities (e.g., place value, tabular formats) are critical for OIM but may be difficult to implement smoothly on mobile devices.","title":"Q13: What are some potential risks to your project?"},{"location":"initial-mockup/#q14-what-are-some-potential-mitigation-strategies-for-the-risks-you-identified","text":"For user interface challenges: Prioritize user testing early with sample icons and flows. Focus on iterative design with feedback from partners in Sierra Leone who already work with target users. For scope creep: Clearly document and re-confirm with partners which features are in-scope vs. out-of-scope . Track any new feature ideas for later phases rather than committing immediately. For collaboration issues: Use a shared GitHub repo and maintain consistent documentation. Weekly sync meetings with Ivan and Marc will help align Android and iOS versions. For gaps in understanding user needs: Leverage partner expertise (Brett and David from MyOralVillage) to validate design assumptions. Conduct walkthroughs of the OIM demo to guide UI design. For technical complexity of graphics: Start with a simplified icon/animation set from the Salone OIM Library and gradually expand. Use Jetpack Compose\u2019s graphics/animation APIs, which are well-suited for custom UI elements.","title":"Q14: What are some potential mitigation strategies for the risks you identified?"},{"location":"user-guide/","text":"User Guide About Orali Money is a collaboration between GNU Taler and My Oral Village to create a mobile wallet that empowers people traditionally excluded from financial systems. This repository is responsible for the Android version of Orali Money which has two interfaces: a standard interface adopted from Taler and an interface built on OIM (Oral Information Management) principles, allowing for illiterate and innumerate adults to interact with the application. Features Sending Money Receiving Money Transaction History (Column) Transaction History (River) Demos Generating a Transaction QR Receiving a Transaction QR Transaction History (River View) Transaction History (Column View) Installation For non developers Please navigate to our most recent release page and download one of the debug APKs. x86_64 (for Windows emulation) arm64 (for native Android phones (Android 8+) or MacOS emulation) armeabi/x86 (for deprecated Android phones; these are rarely needed ) The OIM mode for Android is still in pre-release, therefore there is no official signed release on FDroid/Play store/Nightly as of now. Since full apk optimizations are not run for debugs, the APK sizes are on the larger side (around 40mb). Design Rationale The River View and Metaphor Driven Visualization The river view is one of the most distinctive features of OIM. It comes from extensive research performed by our partners in Sierra Leone who studied how individuals with lower levels of literacy or numeracy understand money. Traditional interfaces filled with numbers, charts, or lists create unnecessary barriers. Highly visual metaphors remove those barriers. Why a River Money behaves like something that moves, divides, or accumulates. A river already communicates this naturally. It lets users understand financial activity by drawing on everyday environmental knowledge. A river can gain water. It can lose water to streams or branches. It can form pools or lakes. It changes shape over time. This makes the metaphor powerful and easy to grasp. Farms as Incoming Money Incoming transactions are represented as farms. Farms are associated with growth, harvest, and gain. When money arrives, the landscape grows, and the user receives something valuable. This framing helps users understand positive inflow without requiring them to read numerical labels. farm size scales with transaction amount placement shows when the transaction occurred tapping opens the exact transaction Lakes as Outgoing Money Outgoing amounts create lakes. A lake is formed by water leaving the main river and gathering elsewhere. This mirrors the idea of money being sent away. lake size grows with the transaction the shape and placement match the timeline each lake opens its corresponding transaction Visual Interaction To support different literacy levels, the river view avoids textual dates. Instead, symbolic date markers appear above each item so users can see approximate timing without needing to read. Every element on the river can be tapped so the visual metaphor stays connected to real financial data. This ensures that the visual storytelling always reflects actual transaction history. Landscape Only Layout OIM does not support portrait mode, and this is intentional. The river metaphor needs horizontal space to breathe. On narrow portrait screens, the metaphor collapses and the UI becomes cramped. Why Landscape Is Necessary Farms, lakes, and the river require width for clear spacing. A horizontal layout offers long uninterrupted movement. Tap areas stay large and easy for users to hit. The banknote stacks and money related visuals remain readable. Layouts look consistent across cheap and expensive phones. Because everything in the app is designed around spatial storytelling, portrait mode would break the core experience. Switching Behavior The main wallet app remains in portrait. Only when the user enters OIM does the device rotate into landscape. Leaving OIM returns the device to portrait. This separation keeps the main app simple while giving OIM the space it needs. Visual Choices and Currency Representation Some UI decisions came directly from partner research in Sierra Leone. These choices reflect what users in the region already understand. Partner Driven Design Partners provided representations for: common note combinations such as forty being shown as twenty stacked on twenty how values should be grouped visually how amounts should scale how certain payment concepts should be represented These decisions came from observing real user behavior in the field. Why TESTKUDOS Uses SLE Notes No assets were supplied for TESTKUDOS. Using generic placeholders would confuse users and break the visual language. SLE notes already fit the user\u2019s mental model and the app\u2019s visual structure. Reusing SLE notes created a consistent experience without introducing noise or ambiguity. Reserved Space in the Send QR Screen Several screens in the Send flow, especially the QR screen, appear to have unused space on one side. This is intentional and directly tied to how the notes column behaves during the send process. When users add multiple notes or mix denominations, the vertical stack can grow quite tall or expand horizontally during animations. Older devices with smaller landscape resolutions (such as Tecno, Itel, or older Samsung models) are especially sensitive to layout compression. If the QR code or other UI elements occupied this region, the growing notes column would begin to overlap the QR code, reduce readability, and make certain buttons difficult to tap. The reserved space ensures the layout remains stable for all device classes, prevents clipping during animations, and guarantees that even very large note stacks never interfere with essential UI interactions.","title":"User Guide"},{"location":"user-guide/#user-guide","text":"","title":"User Guide"},{"location":"user-guide/#about","text":"Orali Money is a collaboration between GNU Taler and My Oral Village to create a mobile wallet that empowers people traditionally excluded from financial systems. This repository is responsible for the Android version of Orali Money which has two interfaces: a standard interface adopted from Taler and an interface built on OIM (Oral Information Management) principles, allowing for illiterate and innumerate adults to interact with the application.","title":"About"},{"location":"user-guide/#features","text":"Sending Money Receiving Money Transaction History (Column) Transaction History (River)","title":"Features"},{"location":"user-guide/#demos","text":"","title":"Demos"},{"location":"user-guide/#generating-a-transaction-qr","text":"","title":"Generating a Transaction QR"},{"location":"user-guide/#receiving-a-transaction-qr","text":"","title":"Receiving a Transaction QR"},{"location":"user-guide/#transaction-history-river-view","text":"","title":"Transaction History (River View)"},{"location":"user-guide/#transaction-history-column-view","text":"","title":"Transaction History (Column View)"},{"location":"user-guide/#installation","text":"","title":"Installation"},{"location":"user-guide/#for-non-developers","text":"Please navigate to our most recent release page and download one of the debug APKs. x86_64 (for Windows emulation) arm64 (for native Android phones (Android 8+) or MacOS emulation) armeabi/x86 (for deprecated Android phones; these are rarely needed ) The OIM mode for Android is still in pre-release, therefore there is no official signed release on FDroid/Play store/Nightly as of now. Since full apk optimizations are not run for debugs, the APK sizes are on the larger side (around 40mb).","title":"For non developers"},{"location":"user-guide/#design-rationale","text":"","title":"Design Rationale"},{"location":"user-guide/#the-river-view-and-metaphor-driven-visualization","text":"The river view is one of the most distinctive features of OIM. It comes from extensive research performed by our partners in Sierra Leone who studied how individuals with lower levels of literacy or numeracy understand money. Traditional interfaces filled with numbers, charts, or lists create unnecessary barriers. Highly visual metaphors remove those barriers.","title":"The River View and Metaphor Driven Visualization"},{"location":"user-guide/#why-a-river","text":"Money behaves like something that moves, divides, or accumulates. A river already communicates this naturally. It lets users understand financial activity by drawing on everyday environmental knowledge. A river can gain water. It can lose water to streams or branches. It can form pools or lakes. It changes shape over time. This makes the metaphor powerful and easy to grasp.","title":"Why a River"},{"location":"user-guide/#farms-as-incoming-money","text":"Incoming transactions are represented as farms. Farms are associated with growth, harvest, and gain. When money arrives, the landscape grows, and the user receives something valuable. This framing helps users understand positive inflow without requiring them to read numerical labels. farm size scales with transaction amount placement shows when the transaction occurred tapping opens the exact transaction","title":"Farms as Incoming Money"},{"location":"user-guide/#lakes-as-outgoing-money","text":"Outgoing amounts create lakes. A lake is formed by water leaving the main river and gathering elsewhere. This mirrors the idea of money being sent away. lake size grows with the transaction the shape and placement match the timeline each lake opens its corresponding transaction","title":"Lakes as Outgoing Money"},{"location":"user-guide/#visual-interaction","text":"To support different literacy levels, the river view avoids textual dates. Instead, symbolic date markers appear above each item so users can see approximate timing without needing to read. Every element on the river can be tapped so the visual metaphor stays connected to real financial data. This ensures that the visual storytelling always reflects actual transaction history.","title":"Visual Interaction"},{"location":"user-guide/#landscape-only-layout","text":"OIM does not support portrait mode, and this is intentional. The river metaphor needs horizontal space to breathe. On narrow portrait screens, the metaphor collapses and the UI becomes cramped.","title":"Landscape Only Layout"},{"location":"user-guide/#why-landscape-is-necessary","text":"Farms, lakes, and the river require width for clear spacing. A horizontal layout offers long uninterrupted movement. Tap areas stay large and easy for users to hit. The banknote stacks and money related visuals remain readable. Layouts look consistent across cheap and expensive phones. Because everything in the app is designed around spatial storytelling, portrait mode would break the core experience.","title":"Why Landscape Is Necessary"},{"location":"user-guide/#switching-behavior","text":"The main wallet app remains in portrait. Only when the user enters OIM does the device rotate into landscape. Leaving OIM returns the device to portrait. This separation keeps the main app simple while giving OIM the space it needs.","title":"Switching Behavior"},{"location":"user-guide/#visual-choices-and-currency-representation","text":"Some UI decisions came directly from partner research in Sierra Leone. These choices reflect what users in the region already understand.","title":"Visual Choices and Currency Representation"},{"location":"user-guide/#partner-driven-design","text":"Partners provided representations for: common note combinations such as forty being shown as twenty stacked on twenty how values should be grouped visually how amounts should scale how certain payment concepts should be represented These decisions came from observing real user behavior in the field.","title":"Partner Driven Design"},{"location":"user-guide/#why-testkudos-uses-sle-notes","text":"No assets were supplied for TESTKUDOS. Using generic placeholders would confuse users and break the visual language. SLE notes already fit the user\u2019s mental model and the app\u2019s visual structure. Reusing SLE notes created a consistent experience without introducing noise or ambiguity.","title":"Why TESTKUDOS Uses SLE Notes"},{"location":"user-guide/#reserved-space-in-the-send-qr-screen","text":"Several screens in the Send flow, especially the QR screen, appear to have unused space on one side. This is intentional and directly tied to how the notes column behaves during the send process. When users add multiple notes or mix denominations, the vertical stack can grow quite tall or expand horizontally during animations. Older devices with smaller landscape resolutions (such as Tecno, Itel, or older Samsung models) are especially sensitive to layout compression. If the QR code or other UI elements occupied this region, the growing notes column would begin to overlap the QR code, reduce readability, and make certain buttons difficult to tap. The reserved space ensures the layout remains stable for all device classes, prevents clipping during animations, and guarantees that even very large note stacks never interfere with essential UI interactions.","title":"Reserved Space in the Send QR Screen"}]}